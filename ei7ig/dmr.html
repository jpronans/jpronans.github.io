<!DOCTYPE html>
<html>
	<head>
	<title>Digital Mobile Radio</title>
	  <meta charset="UTF-8">
	  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.js"></script>
	  <script type= "text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.2.10/semantic.min.js"></script>
	  <script src="https://cdnjs.cloudflare.com/ajax/libs/handlebars.js/4.0.8/handlebars.min.js"></script>
	  <link rel="stylesheet" media="screen" href="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.2.10/semantic.min.css">
	</head>
	<body bgcolor="#ffffff" link="#0000ff" vlink="#800080">
	  	<!-- navigation menu template -->
	  	<div class="navbar-menu-placeholder"></div>
	  	<script src="public/javascript/navbar-menu.js"></script>
    <section>
    <h1>Proposed Talkgroups</h1>
    <ul>
    <li>2722  - Ireland Calling Channel (Also accessible via reflector 4780 on BrandMeister)</li>
    <li>2723  - Ireland Chat</li>
    <li>2724  - Ireland Wires Bridge</li>
    <li>2729  - AREN Tactical</li>
    <li>27291 - AREN Logistics</li>
    <li>27240 - Southern Ireland Repeater Network (Testing)</li>
    <li>272997 - Parrot/Echo</li>
    </ul>

    <h2>Talkgroups</h2>
    My understanding so far is that on the Brandmeister Network, is that Talkgroups can be used on either slot. However, the current plan is to adopt the Norwegian model. Local/National on Slot 2, Reflectors/International on Slot 1. With good practice to move to slot 1 for long chats to keep slot 2 clear for local/calling traffic <a href="https://wiki.brandmeister.network/index.php/Ireland">BrandMeister Ireland</a>.

    
    <h2>Reflectors</h2>
    Reflectors are only repeaters that can be accessed by dynamically dialling them. Limited to only be used on slot 2 (Brandmeister).

    <h2>Useful Links</h2>
    <ul>
    <li><a href="http://www.dmr-marc.net/media/Amateur_Radio_Guide_to_DMR_Rev_I_20150510.pdf">Amateur Guide to DMR</a> from 2015. No mention of Brandmeister</li>
    <li><a href="https://www.youtube.com/watch?v=sDBosrVDrOA">Programming the MD-390/RT8</a> (Youtube)</li>
    <li><a href="http://brandmeisternetwork.blogspot.ie/2016/12/brandmeister-reflectors-talkgroups-list.html">On Brandmeister reflectors</a></li>
    <li><a href="public/files/codeplug-ei7ig.rdt">My current example codeplug</a> for my Retevis RT8 (last uploaded 2018-02-20)</li>
    </ul>
    </section>
    <section>
    <h3>Codeplug Editors</h3>
    <ul>
    <li><a href="http://www.miklor.com/MD380/380-CPEditor.php>">Mikor Codeplug Editor</a> 
    <li><a href="http://g7rvh.com/tyt-md-380/codeplug-editor/">G7RVH Codeplug Editor</a> 
    </ul>
    I have not used either of the above, so comments as to how good they are, are welcome.  
    </section>
    <section>
    <h2>Radios</h2>
      <p>
        I currently have the Retevis <a href="http://www.retevis.com/rt8/">RT8</a> and a <a href="https://www.motorolasolutions.com/en_xu/products/mototrbo/dm4000-series-mobile-radios/dm4600-dm4601.html#tabproductinfo">Motorola DM4600</a>.
        Initial impressions are that I like the DM4600 and the roaming function appears to work quite well.
      </p>
    </section>
  
    <section class="ui raised segment">
      <h1 id="rt8">Extracting GPS Data from the Retevis RT8</h1>
      <p>
      These notes are largely for my own benefit. My motiviation was pretty simple.  I had purchased the Retevis RT8 and, as I am interested in the use of APRS and other tracking technologies for Public Service (<a href="http://www.aren.ie">AREN</a>), I simply wanted to get the GPS function working.
      </p>
      <p>
      So with that in mind I started by turning on debugging in MMDVM and see what I could figure out. I posted a <a href="https://groups.yahoo.com/neo/groups/mmdvm/conversations/messages/13009">question</a> to the MMDVM group outlining my initial findings. 
      </p>
      <p>
      From that, I had some discussions with Jonathan Naylor, G4KLX regarding the UDT Header, and we determined that MMDVM was dropping a frame at the end of each transmission when the GPS was enabled (<a href="https://github.com/g4klx/MMDVMHost/commit/68b8ba031fdc50a5c2603275c892fe6ce6e9ce6f">the fix</a>).
      </p>
      <p>
      I also came across <a href="https://groups.google.com/forum/#!topic/md380tools/GDm-aOuPV2g">this</a> thread where Carlos, EB4FBZ had done some work decoding the GPS data from the MD-390.
      </p>
      <pre>
        Hello Michael, these are my notes in 0 based indexing:

        bit 0: Not used
        bit 1 : 1=N, 0=S
        bit 2 : 1=E, 0=W
        bit 3 : Fix
        bits(4:10): Speed in knots/2
        bits(11:17): Latitude. Degrees
        bits(18:23): Latitude. Minutes integer part
        bits(24:37): Latitude. Minutes decimal part
        bits(38:45): Longitude. Degrees
        bits(46:51): Longitude. Minutes integer part
        bits(52:65): Longitude. Minutes decimal part
        bits(66:79): Altitude in meters, only least 8bits used (bug)
        bits(80:95): Garbage?

        This is working on BM network since 2 weeks ago, i'm pretty sure it's correct. I injected simulated NMEA frames into the radio instead of the real GPS ones and tested each value.

        Best regards,
        Carlos EB4FBZ
      </pre>
      <p>
      So with this information I set about figuring out the data stream. This was a pretty much done by brute force i.e. lots of debugging statements.
      </p>
      <p>
      Firstly I set about figuring out what my RT8 was sending this was the first packet I saw:
      </p>
      <pre>
      00 05 04 2A 67 29 81 32 00 1B 42 A8
      </pre>
      <p>
      Breaking the bytes down further (from left to right) into individual bits (see <a href="http://www.etsi.org/deliver/etsi_ts/102300_102399/10236101/02.02.01_60/ts_10236101v020201p.pdf">ETSI TS 102 361-1 - V2.2.1</a> Page 79), this is what you get:
      <pre>
      00 = 0000 0000  
      Bit  7   = Individial (0) or Talkgroup (1) is the destination  
           6   = Response Requested (1) 
           5   = 0
           4   = 0
      Bits 3-0 = 0000 = UDT Data transport Format is Binary (see <a href="http://www.etsi.org/deliver/etsi_ts/102300_102399/10236101/02.02.01_60/ts_10236101v020201p.pdf">ETSI TS 102 361-1 - V2.2.1 Page 109</a>)

      05 = 0000 0101
      Bits 7-4 = 0000 = UDT Service Access Point ID (see <a href="http://www.etsi.org/deliver/etsi_ts/102300_102399/10236101/02.02.01_60/ts_10236101v020201p.pdf">ETSI TS 102 361-1 - V2.2.1 Page 103</a>)
      Bist 3-0 = 0101 = NMEA location coded (see <a href="http://www.etsi.org/deliver/etsi_ts/102300_102399/10236101/02.02.01_60/ts_10236101v020201p.pdf">ETSI TS 102 361-1 - V2.2.1 Page 109</a>)


      04 2A 67 = 0000 0100 0020 1100 0101 0111 = Destination Logical Link ID = 272999 (Destination DMR ID set in my Codeplug)

      29 81 32 = 0010 1001 1000 0001 0011 0010 = Source Logical Link ID = 2720050 (My DMR ID)

      00 = 0000 0000
      Bits 7-3 = 00000 = Pad Nibble
      Bit    2 = 0     = Reserved
      Bits 1-0 = 00    = 1 Appended Data UDT Blocks 
      
      1B = 0001 1011   
      Bit    7 = 0      = Supplementary Flag
             6 = 0      = Protect Flag (Reserved for Future Use)
      Bits 5-0 = 011011 = UDT Opcode = Unified Data Transport inbound Header (see <a href="http://www.etsi.org/deliver/etsi_ts/102300_102399/10236104/01.07.01_60/ts_10236104v010701p.pdf">ETSI TS 102-361-4 v1.7.1</a>, page 252 Table B.1)

      42 A8 = Header CRC which I really wasn't concerned about.   
      </pre>

      Noticing that '00' meant '1 Appended Data UDT Block' was the first useful thing I found.

      So, now to deal with the appended data frame. It turns out this is in the Short NMEA format (see <a href="http://www.etsi.org/deliver/etsi_ts/102300_102399/10236104/01.07.01_60/ts_10236104v010701p.pdf">ETSI TS 102-361-4 v1.7.1</a>, page 262).  
      <pre>
      50 0D 09 98 00 1C 96 50 80 3F C7 B8
      </pre>
      <pre>
      50 = 0101 0000 
      Bit    7 = 0 = Encrypted (1), not encrypted (0)         = Not encrypted
             6 = 1 = Latitude Direction, North(1), South(0)   = North
             5 = 0 = Longitude Direction, East(1), West(0)    = West
             4 = 1 = GPS Quality Indicator Fix (1), No Fix(0) = GPS Fix
      Bits 3-0 = 0000 = Top 4 bits of the Speed in knots
      
      0D = 0000 1101
      Bits 7-5 = 000   = Bottom 3 bits of the Speed in knots (127 = Greater than 126 knots)
      Bits 4-0 = 01101 = Top 5 bits of Latitude Degrees 

      Speed = 0000000 = 0 Knots

      The notes from Carlos, EB4FBZ suggest that this is knots/2. I haven't had the opportunity to test this yet.
      
      09 = 0000 1001 
      Bits 7-6 = 00     = Bottom 2 bits of Latitude Degrees (0-89)
      Bits 5-0 = 001001 = Latitude Minutes (00-59) 

      Latitude Degrees = 0110100 = 52 Degrees
      Latitude Minutes = 001001  = 9 Minutes
      
      98 = 1001 1000     = Top 8 bits of Latitude Fractions of minutes 

      00 = 0000 0000 
      Bits 7-2 = 000000  = Bottom 6 bits of Latitude Fractions of minutes (0000-9999)
      Bits 1=0 = 00      = Top two bits of Longitude Degrees

      Latitude fractions of minutes = 10 0110 0000 0000 = 9728

      1C = 0001 1100
      Bits 7-2 = 000111  = Bottom 6 bits of Longitude Degrees (000-179)
      bits 1-0 = 00      = Top two bits of Longitude Minutes
      
      Longitude Degrees = 0000 0111 = 7

      96 = 1001 0110 
      Bits 7-4 = 1001 = Bottom 4 bits of Longitude Minutes (00-59)
      Bits 3-0 = 0110 = Top 4 bits of Longitude Fractions of minutes 

      Longitude Minutes = 001001 = 9

      50 = 0101 0000 = Bits 10-3 of Longitude Fractions of minutes

      </pre>
      <p>
      At this point the Radio appears to diverge from the specifications as per the notes from Carlos EB4FBZ and I'm taking the next 14 bits as Altitude in Meters which appears to be correct so far.  As of writing I have not tested what happens when the altitude is negative.
      </p>
      <pre>
      80 = 1000 0000 
      Bits 7-6 = 10 = Bottom two bits of Longitude Fractions of Minutes (0000-9999)
      
      Bits 5-0 = 00000 = Top 6 bits of Altitude
      Longitude fractions of minutes = 0110 0101 0000 10 = 6466

      3F = 0011 1111 = Bottom 8 bits of Altitude   

      Altitude = 00 0000 0011 1111 = 63 Meters
      </pre>
      <p>
      So fully decoded that gives:
      <ul>
      <li>Speed = 0</li>
      <li>52 9 9728 = 52.1662N</li> 
      <li>7 9 6446 = 7.1607W</li> 
      <li>Altitude = 63 Meters</li>
      </ul>

      Thats about all there is too it! I'm not really in a position to test 'speed' yet so I'm not pushing that to the APRS-IS yet, once I'm confident that it is correct. I will update the code. 

      Finally, If anyone had a loaner of a different manufacturer's DMR radio, I could have a look at decoding those as well.

      My code currently exists <a href="https://github.com/jpronans/DMRGateway">here</a> on github.  With regular git pulls to the GPS branch of the <a href="https://github.com/g4klx/DMRGateway">main</a> codebase.
      </p>
    </section>

  
	</body>
</html>
